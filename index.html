<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Simplifying Algebraic Expressions â€“ Mr. McLean Math</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #f5f5f5;
      --fg: #222222;
      --accent: #2b7cff;
      --accent-soft: #e2ecff;
      --error: #c62828;
      --correct: #2e7d32;
      --panel: #ffffff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--fg);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      background: var(--accent);
      color: #ffffff;
      padding: 0.75rem 1rem;
      text-align: center;
      font-size: 1.1rem;
      font-weight: 600;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0.75rem;
      max-width: 1200px;
      margin: 0 auto;
      gap: 0.75rem;
    }

    .top-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .card {
      background: var(--panel);
      border-radius: 0.75rem;
      padding: 0.75rem 1rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .card h2 {
      margin-top: 0;
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .mode-switch {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }

    .mode-button {
      border: 1px solid var(--accent);
      background: #ffffff;
      color: var(--accent);
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .mode-button.active {
      background: var(--accent);
      color: #ffffff;
    }

    .difficulty-row {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }

    .difficulty-button {
      border-radius: 999px;
      padding: 0.3rem 0.7rem;
      border: 1px solid #cccccc;
      background: #ffffff;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }

    .difficulty-button span.emoji { font-size: 1rem; }

    .difficulty-button.active {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--fg);
      font-weight: 600;
    }

    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }

    .toggle-group {
      display: flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.85rem;
    }

    .toggle-group select { font-size: 0.85rem; }

    .switch-label {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      cursor: pointer;
    }

    .switch-label input { cursor: pointer; }

    .game-area {
      flex: 1;
      min-width: 260px;
    }

    .expression-display {
      text-align: center;
      font-size: 2.1rem;
      font-weight: 600;
      margin: 0.75rem 0;
      word-wrap: break-word;
    }

    .expression-display.small { font-size: 1.6rem; }

    .input-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    #answerInput {
      min-width: 230px;
      max-width: 480px;
      width: 100%;
      padding: 0.4rem 0.6rem;
      font-size: 1.1rem;
      border-radius: 0.5rem;
      border: 1px solid #cccccc;
    }

    button.primary {
      background: var(--accent);
      border: none;
      color: #ffffff;
      padding: 0.4rem 0.9rem;
      font-size: 0.95rem;
      border-radius: 0.5rem;
      cursor: pointer;
    }

    button.secondary {
      background: #ffffff;
      border: 1px solid #cccccc;
      color: var(--fg);
      padding: 0.35rem 0.75rem;
      font-size: 0.9rem;
      border-radius: 0.5rem;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .feedback-panel {
      font-size: 0.9rem;
      border-top: 1px solid #e0e0e0;
      padding-top: 0.5rem;
      margin-top: 0.5rem;
    }

    .feedback-status { font-weight: 600; }

    .feedback-status.correct { color: var(--correct); }
    .feedback-status.incorrect { color: var(--error); }

    .steps {
      margin-top: 0.3rem;
      font-size: 0.85rem;
      white-space: pre-line;
    }

    .score-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      font-size: 0.85rem;
      margin-top: 0.4rem;
    }

    .summary-toggle {
      margin-top: 0.3rem;
      font-size: 0.85rem;
    }

    details summary { cursor: pointer; }

    .summary-list {
      font-size: 0.85rem;
      margin-top: 0.25rem;
    }

    .summary-list ul {
      padding-left: 1.1rem;
      margin: 0.2rem 0;
    }

    .timer-display {
      font-weight: 600;
      min-width: 2.2rem;
      text-align: center;
    }

    .worksheet-area {
      display: none;
      flex-direction: column;
      gap: 0.5rem;
    }

    .worksheet-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.85rem;
    }

    .worksheet-list {
      margin-top: 0.5rem;
      font-size: 1rem;
    }

    .worksheet-list ol {
      margin: 0.25rem 0;
      padding-left: 1.4rem;
    }

    .worksheet-list li { margin-bottom: 0.9rem; }

    .worksheet-answer {
      font-size: 0.9rem;
      color: #555555;
      margin-top: 0.15rem;
    }

    footer {
      text-align: center;
      padding: 0.5rem;
      font-size: 0.8rem;
      color: #666666;
    }

    #dev-panel {
      display: none;
      font-size: 0.8rem;
      margin-top: 0.5rem;
      border-top: 1px dashed #cccccc;
      padding-top: 0.5rem;
    }

    #dev-panel pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background: #fafafa;
      padding: 0.4rem;
      border-radius: 0.3rem;
      border: 1px solid #e0e0e0;
      max-height: 200px;
      overflow: auto;
    }

    @media (max-width: 800px) {
      .expression-display { font-size: 1.8rem; }
    }

    @media (max-width: 600px) {
      main { padding: 0.5rem; }
      .expression-display { font-size: 1.6rem; }
    }
  </style>
</head>
<body>
  <header>
    Simplifying Algebraic Expressions â€“ Practice Game
  </header>

  <main>
    <div class="top-row">
      <div class="card" style="flex: 1 1 260px;">
        <h2>Mode &amp; Settings</h2>

        <div class="mode-switch" aria-label="Mode selection">
          <button class="mode-button active" id="gameModeBtn">Game mode</button>
          <button class="mode-button" id="worksheetModeBtn">Worksheet mode</button>
        </div>

        <div>
          <strong>Difficulty</strong>
          <div class="difficulty-row" aria-label="Difficulty selection">
            <button class="difficulty-button active" data-diff="easy">
              <span class="emoji">ðŸŸ¢</span><span>Easy</span>
            </button>
            <button class="difficulty-button" data-diff="medium">
              <span class="emoji">ðŸŸ¡</span><span>Medium</span>
            </button>
            <button class="difficulty-button" data-diff="hard">
              <span class="emoji">ðŸ”´</span><span>Hard</span>
            </button>
            <button class="difficulty-button" data-diff="random">
              <span class="emoji">ðŸŽ²</span><span>Mixed</span>
            </button>
          </div>
        </div>

        <div class="controls-row" aria-label="Game controls">
          <div class="toggle-group">
            <span>Timer:</span>
            <label class="switch-label">
              <input type="checkbox" id="timerToggle" />
              <span>On</span>
            </label>
            <select id="timerSelect">
              <option value="30">30 s</option>
              <option value="60">60 s</option>
              <option value="90">90 s</option>
              <option value="120">120 s</option>
            </select>
            <span class="timer-display" id="timerDisplay">--</span>
          </div>

          <div class="toggle-group">
            <label class="switch-label">
              <input type="checkbox" id="soundToggle" checked />
              <span>Sound</span>
            </label>
          </div>

          <div class="toggle-group">
            <label class="switch-label">
              <input type="checkbox" id="contrastToggle" />
              <span>High contrast</span>
            </label>
          </div>
        </div>
      </div>

      <div class="card game-area" id="gameArea">
        <h2>Game mode</h2>
        <div id="instructionText" style="font-size:0.9rem;">
          Simplify the expression. Write the answer without parentheses.
        </div>
        <div id="expressionDisplay" class="expression-display" aria-live="polite">
          â€“
        </div>

        <div class="input-row">
          <input
            id="answerInput"
            type="text"
            autocomplete="off"
            placeholder="Write your simplified expression here (for example: 5xÂ² + 3x - 2)"
            aria-label="Type your answer"
          />
          <button id="submitBtn" class="primary">Submit</button>
          <button id="nextBtn" class="secondary">Next</button>
        </div>

        <div class="feedback-panel" aria-live="polite">
          <div id="feedbackStatus" class="feedback-status">
            &nbsp;
          </div>
          <button id="showStepsBtn" class="secondary" style="margin-top:0.25rem; display:none;">
            Show steps
          </button>
          <div id="stepsContainer" class="steps"></div>

          <div class="score-row">
            <div>Score: <span id="scoreDisplay">0</span></div>
            <div>Streak: <span id="streakDisplay">0</span></div>
            <div>Best streak: <span id="bestStreakDisplay">0</span></div>
            <div>Correct: <span id="correctDisplay">0</span></div>
            <div>Total: <span id="totalDisplay">0</span></div>
            <div>Accuracy: <span id="accuracyDisplay">0%</span></div>
          </div>

          <div class="summary-toggle">
            <details id="summaryDetails">
              <summary>Session summary (incorrect questions)</summary>
              <div class="summary-list" id="summaryList">
                No incorrect answers yet.
              </div>
            </details>
          </div>
        </div>

        <div id="dev-panel" class="card">
          <h2>Developer Tests</h2>
          <pre id="dev-output"></pre>
        </div>
      </div>

      <div class="card worksheet-area" id="worksheetArea">
        <h2>Worksheet mode</h2>
        <div class="worksheet-controls">
          <div>
            <label for="worksheetCountSelect">Number of problems:</label>
            <select id="worksheetCountSelect">
              <option value="5">5</option>
              <option value="10">10</option>
              <option value="15">15</option>
            </select>
          </div>
          <div>
            <label for="worksheetDiffSelect">Difficulty:</label>
            <select id="worksheetDiffSelect">
              <option value="easy">ðŸŸ¢ Easy</option>
              <option value="medium">ðŸŸ¡ Medium</option>
              <option value="hard">ðŸ”´ Hard</option>
              <option value="random" selected>ðŸŽ² Mixed</option>
            </select>
          </div>
          <button id="generateWorksheetBtn" class="primary">
            Generate worksheet
          </button>
          <button id="revealAllBtn" class="secondary" disabled>
            Reveal all
          </button>
          <button id="hideAllBtn" class="secondary" disabled>
            Hide all
          </button>
        </div>

        <div style="font-size:0.9rem; margin-top:0.25rem;">
          Instruction header: <strong>Simplify the expressions.</strong>
        </div>

        <div class="worksheet-list" id="worksheetList">
          No worksheet generated yet.
        </div>
      </div>
    </div>
  </main>

  <footer>
    Created by Mr. McLean Math.
  </footer>

  <script>
    /*********************
     * Utility: formatting
     *********************/

    function formatWithSpaces(num) {
      const sign = num < 0 ? "-" : "";
      let s = String(Math.abs(num));
      if (s.length <= 3) return sign + s;
      let out = "";
      while (s.length > 3) {
        out = " " + s.slice(-3) + out;
        s = s.slice(0, -3);
      }
      out = s + out;
      return sign + out;
    }

    function prettyExpr(s) {
      return String(s)
        .replace(/\^2/g, "Â²")
        .replace(/\^3/g, "Â³");
    }

    /*********************
     * Polynomial engine
     * representation: { key: coefficient }
     * key "" => constant term
     *********************/

    function clonePoly(p) {
      const res = {};
      for (const k in p) {
        if (Object.prototype.hasOwnProperty.call(p, k)) {
          if (p[k] !== 0) res[k] = p[k];
        }
      }
      return res;
    }

    function makeConst(c) {
      return c === 0 ? {} : { "": c };
    }

    function makeMono(coef, varMap) {
      if (coef === 0) return {};
      const key = varMapToKey(varMap);
      return { [key]: coef };
    }

    function varMapToKey(map) {
      const vars = Object.keys(map).filter((v) => map[v] !== 0);
      if (vars.length === 0) return "";
      vars.sort();
      const parts = vars.map((v) => {
        const e = map[v];
        return e === 1 ? v : v + "^" + e;
      });
      return parts.join("*");
    }

    function keyToVarMap(key) {
      if (!key) return {};
      const map = {};
      const parts = key.split("*");
      for (const part of parts) {
        const m = part.match(/^([a-zA-Z])(?:\^(\d+))?$/);
        if (!m) continue;
        const v = m[1];
        const e = m[2] ? parseInt(m[2], 10) : 1;
        map[v] = (map[v] || 0) + e;
      }
      return map;
    }

    function addPolys(p, q) {
      const res = clonePoly(p);
      for (const k in q) {
        if (!Object.prototype.hasOwnProperty.call(q, k)) continue;
        res[k] = (res[k] || 0) + q[k];
        if (res[k] === 0) delete res[k];
      }
      return res;
    }

    function subPolys(p, q) {
      const res = clonePoly(p);
      for (const k in q) {
        if (!Object.prototype.hasOwnProperty.call(q, k)) continue;
        res[k] = (res[k] || 0) - q[k];
        if (res[k] === 0) delete res[k];
      }
      return res;
    }

    function mulPolys(p, q) {
      const res = {};
      for (const k1 in p) {
        if (!Object.prototype.hasOwnProperty.call(p, k1)) continue;
        const c1 = p[k1];
        const vm1 = keyToVarMap(k1);
        for (const k2 in q) {
          if (!Object.prototype.hasOwnProperty.call(q, k2)) continue;
          const c2 = q[k2];
          const vm2 = keyToVarMap(k2);
          const merged = {};
          for (const v in vm1) merged[v] = (merged[v] || 0) + vm1[v];
          for (const v in vm2) merged[v] = (merged[v] || 0) + vm2[v];
          const key = varMapToKey(merged);
          res[key] = (res[key] || 0) + c1 * c2;
          if (res[key] === 0) delete res[key];
        }
      }
      return res;
    }

    function polyToString(p) {
      const terms = [];
      for (const k in p) {
        if (!Object.prototype.hasOwnProperty.call(p, k)) continue;
        const c = p[k];
        if (c === 0) continue;
        const vm = keyToVarMap(k);
        let degree = 0;
        for (const v in vm) degree += vm[v];
        terms.push({ key: k, coef: c, degree });
      }
      if (terms.length === 0) return "0";

      terms.sort((a, b) => {
        if (b.degree !== a.degree) return b.degree - a.degree;
        if (a.key < b.key) return -1;
        if (a.key > b.key) return 1;
        return 0;
      });

      let result = "";
      for (let i = 0; i < terms.length; i++) {
        const { key, coef } = terms[i];
        const abs = Math.abs(coef);
        const sign = coef < 0 ? "-" : "+";

        let mono = "";
        if (key === "") {
          mono = formatWithSpaces(abs);
        } else {
          const varPartRaw = key
            .split("*")
            .map((part) => part.replace(/\^(\d+)/, "^$1"))
            .join("");
          const varPart = varPartRaw
            .replace(/\^2/g, "Â²")
            .replace(/\^3/g, "Â³");
          if (abs === 1) {
            mono = varPart;
          } else {
            mono = formatWithSpaces(abs) + varPart;
          }
        }

        if (i === 0) {
          result += coef < 0 ? "-" + mono : mono;
        } else {
          result += " " + sign + " " + mono;
        }
      }
      return result;
    }

    /*************************
     * Parse simplified answer
     *************************/

    function parseSimplifiedPolynomial(input) {
      let raw = (input || "").trim();
      if (!raw) return { ok: false, error: "Answer is empty." };

      // Allow users to type Â² and Â³; normalize them internally to ^2/^3
      raw = raw.replace(/Â²/g, "^2").replace(/Â³/g, "^3");

      if (/[()]/.test(raw)) {
        return {
          ok: false,
          error: "Do not use parentheses in the final answer. Expand and combine all terms."
        };
      }
      if (/[.,]/.test(raw)) {
        return {
          ok: false,
          error: "Use whole-number coefficients only (no decimals)."
        };
      }

      const s = raw.replace(/\s+/g, "");
      let str = s;
      if (str[0] !== "-" && str[0] !== "+") {
        str = "+" + str;
      }
      str = str.replace(/-/g, "+-");

      const parts = str.split("+").filter((t) => t !== "");
      const poly = {};

      for (const term of parts) {
        const m = term.match(/^(-)?(\d+)?([a-zA-Z][a-zA-Z0-9^]*)?$/);
        if (!m) {
          return {
            ok: false,
            error:
              "Could not understand part of your answer: '" +
              term +
              "'. Use terms like 3x, -2aÂ²b, 5."
          };
        }
        const negative = !!m[1];
        const numPart = m[2];
        const varPart = m[3] || "";

        let coef;
        if (numPart) {
          coef = parseInt(numPart, 10);
        } else {
          coef = varPart ? 1 : 0;
        }
        if (negative) coef = -coef;

        let key = "";
        if (varPart) {
          const map = {};
          const varMatches = varPart.match(/[a-zA-Z](?:\^\d+)?/g);
          if (!varMatches) {
            return {
              ok: false,
              error:
                "Could not read the variables in '" +
                term +
                "'. Use forms like x, yÂ², ab, aÂ²b."
            };
          }
          for (const vseg of varMatches) {
            const vm = vseg.match(/^([a-zA-Z])(?:\^(\d+))?$/);
            if (!vm) {
              return {
                ok: false,
                error:
                  "Problem with variable part '" +
                  vseg +
                  "'. Use simple letters with optional powers like xÂ²."
              };
            }
            const v = vm[1];
            const power = vm[2] ? parseInt(vm[2], 10) : 1;
            map[v] = (map[v] || 0) + power;
          }
          key = varMapToKey(map);
        }

        if (coef !== 0) {
          poly[key] = (poly[key] || 0) + coef;
          if (poly[key] === 0) delete poly[key];
        }
      }

      return { ok: true, poly };
    }

    /***********************
     * Random helpers
     ***********************/

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randNonZero(min, max) {
      let n = 0;
      while (n === 0) n = randInt(min, max);
      return n;
    }

    function pick(arr) {
      return arr[randInt(0, arr.length - 1)];
    }

    function signStr(n) {
      return n < 0 ? "-" : "+";
    }

    function fmtSigned(n) {
      return (n < 0 ? "- " + Math.abs(n) : "+ " + n);
    }

    function safeVar() {
      // avoid z as requested
      return pick(["x", "y", "a", "b", "c", "m", "n", "p", "q", "r", "t"]);
    }

    function safeVarPair() {
      const v1 = safeVar();
      let v2 = safeVar();
      while (v2 === v1) v2 = safeVar();
      return [v1, v2];
    }

    /*************************************
     * No-repeat memory (persists refresh)
     *************************************/

    const RECENT_LIMIT = 120; // change if you want (higher = fewer repeats, slightly more retries)
    const RECENT_KEY = "mclean_simplify_recent_v2";

    function loadRecent() {
      try {
        const raw = localStorage.getItem(RECENT_KEY);
        if (!raw) return { easy: [], medium: [], hard: [] };
        const obj = JSON.parse(raw);
        return {
          easy: Array.isArray(obj.easy) ? obj.easy : [],
          medium: Array.isArray(obj.medium) ? obj.medium : [],
          hard: Array.isArray(obj.hard) ? obj.hard : []
        };
      } catch (e) {
        return { easy: [], medium: [], hard: [] };
      }
    }

    function saveRecent(store) {
      try {
        localStorage.setItem(RECENT_KEY, JSON.stringify(store));
      } catch (e) {
        // ignore
      }
    }

    const recentStore = loadRecent();

    function signatureFor(prob) {
      // Canonical signature based on final simplified polynomial + difficulty + a short expr hint
      // This avoids repeats even if different templates simplify to same result.
      const final = polyToString(prob.poly);
      const exprHint = String(prob.expr).replace(/\s+/g, "");
      return prob.difficulty + "||" + final + "||" + exprHint;
    }

    function seenRecently(diff, sig) {
      const arr = recentStore[diff] || [];
      return arr.indexOf(sig) !== -1;
    }

    function remember(diff, sig) {
      const arr = recentStore[diff] || [];
      arr.push(sig);
      while (arr.length > RECENT_LIMIT) arr.shift();
      recentStore[diff] = arr;
      saveRecent(recentStore);
    }

    /***********************
     * Problem generators
     * Each returns:
     * { expr, poly, steps, difficulty }
     ***********************/

    // Template builders (keep coefficients reasonable)
    function genCombineLikeOneVar(v, termsCount, coefMin, coefMax, constMin, constMax) {
      const coefs = [];
      for (let i = 0; i < termsCount; i++) coefs.push(randNonZero(coefMin, coefMax));
      const c = randInt(constMin, constMax);

      // Build expression with random +/- signs but keep it readable
      const pieces = [];
      for (let i = 0; i < coefs.length; i++) {
        const k = coefs[i];
        const sign = i === 0 ? "" : (k < 0 ? " - " : " + ");
        pieces.push(sign + Math.abs(k) + v);
      }
      if (c !== 0) {
        pieces.push(c < 0 ? " - " + Math.abs(c) : " + " + c);
      }
      const expr = pieces.join("");

      let poly = {};
      for (const k of coefs) poly = addPolys(poly, makeMono(k, { [v]: 1 }));
      poly = addPolys(poly, makeConst(c));

      const sum = coefs.reduce((a, b) => a + b, 0);
      const steps =
        `${expr}\n` +
        `= (${coefs.join(" + ").replace(/\+\s-\s/g, "- ")})${v}` + (c !== 0 ? ` ${c < 0 ? "- " + Math.abs(c) : "+ " + c}` : "") + `\n` +
        `= ${sum}${v}` + (c !== 0 ? ` ${c < 0 ? "- " + Math.abs(c) : "+ " + c}` : "");

      return { expr, poly, steps };
    }

    function genTwoVarLikeTerms(v1, v2) {
      const a1 = randNonZero(1, 9);
      const a2 = randNonZero(1, 9);
      const b1 = randNonZero(1, 9);
      const b2 = randNonZero(1, 9);
      const c = randInt(-9, 9);

      const expr = `${a1}${v1} + ${a2}${v1} - ${b1}${v2} + ${b2}${v2}` + (c !== 0 ? (c < 0 ? ` - ${Math.abs(c)}` : ` + ${c}`) : "");
      let poly = {};
      poly = addPolys(poly, makeMono(a1 + a2, { [v1]: 1 }));
      poly = addPolys(poly, makeMono(-b1 + b2, { [v2]: 1 }));
      poly = addPolys(poly, makeConst(c));

      const steps =
        `${expr}\n` +
        `= (${a1} + ${a2})${v1} + (${ -b1 } + ${ b2 })${v2}` + (c !== 0 ? (c < 0 ? ` - ${Math.abs(c)}` : ` + ${c}`) : "") + `\n` +
        `= ${a1 + a2}${v1} ${(-b1 + b2) < 0 ? "- " + Math.abs(-b1 + b2) + v2 : "+ " + (-b1 + b2) + v2}` + (c !== 0 ? (c < 0 ? ` - ${Math.abs(c)}` : ` + ${c}`) : "");

      return { expr, poly, steps };
    }

    function genDistributeLinear(v) {
      const k = randNonZero(2, 9);
      const a = randNonZero(1, 9);
      const b = randInt(-9, 9);
      // k(ax + b)
      const inner = `${a}${v}` + (b === 0 ? "" : (b < 0 ? ` - ${Math.abs(b)}` : ` + ${b}`));
      const expr = `${k}(${inner})`;
      const poly = addPolys(makeMono(k * a, { [v]: 1 }), makeConst(k * b));
      const steps =
        `${expr}\n` +
        `= ${k}Â·${a}${v}` + (b === 0 ? "" : ` ${b < 0 ? "- " : "+ "}${k}Â·${Math.abs(b)}`) + `\n` +
        `= ${k * a}${v}` + (b === 0 ? "" : ` ${k * b < 0 ? "- " + Math.abs(k * b) : "+ " + (k * b)}`);
      return { expr, poly, steps };
    }

    function genMultiplyMonomials() {
      const [v1, v2] = safeVarPair();
      const c1 = randNonZero(1, 9);
      const c2 = randNonZero(1, 9);

      // choose pattern: same var squared, or two vars -> product
      const pat = randInt(1, 3);
      if (pat === 1) {
        const expr = `${c1}${v1} Â· ${c2}${v1}`;
        const poly = makeMono(c1 * c2, { [v1]: 2 });
        const steps = `${expr}\n= ${c1 * c2}${v1}Â²`;
        return { expr, poly, steps };
      } else if (pat === 2) {
        const expr = `${c1}${v1} Â· ${c2}${v2}`;
        const poly = makeMono(c1 * c2, { [v1]: 1, [v2]: 1 });
        const steps = `${expr}\n= ${c1 * c2}${v1}${v2}`;
        return { expr, poly, steps };
      } else {
        // include exponent times variable: (c1*v1^2) * (c2*v1)
        const expr = `${c1}${v1}Â² Â· ${c2}${v1}`;
        const poly = makeMono(c1 * c2, { [v1]: 3 });
        const steps = `${expr}\n= ${c1 * c2}${v1}Â³`;
        return { expr, poly, steps };
      }
    }

    function genBinomialTimesBinomialSameVar(v) {
      const a = randInt(-9, 9);
      const b = randInt(-9, 9);
      const expr = `(${v} ${a < 0 ? "- " + Math.abs(a) : "+ " + a}) (${v} ${b < 0 ? "- " + Math.abs(b) : "+ " + b})`;
      const p1 = addPolys(makeMono(1, { [v]: 1 }), makeConst(a));
      const p2 = addPolys(makeMono(1, { [v]: 1 }), makeConst(b));
      const poly = mulPolys(p1, p2);
      const steps =
        `${expr}\n` +
        `= ${v}Â·${v} ${b < 0 ? "- " + Math.abs(b) + v : "+ " + b + v} ${a < 0 ? "- " + Math.abs(a) + v : "+ " + a + v} ${a*b < 0 ? "- " + Math.abs(a*b) : "+ " + (a*b)}\n` +
        `= ${polyToString(poly)}`;
      return { expr, poly, steps };
    }

    function genSquareBinomial(v) {
      const a = randInt(-9, 9);
      const expr = `(${v} ${a < 0 ? "- " + Math.abs(a) : "+ " + a})Â²`;
      const p = addPolys(makeMono(1, { [v]: 1 }), makeConst(a));
      const poly = mulPolys(p, p);
      const steps =
        `${expr}\n` +
        `= (${v} ${a < 0 ? "- " + Math.abs(a) : "+ " + a})(${v} ${a < 0 ? "- " + Math.abs(a) : "+ " + a})\n` +
        `= ${polyToString(poly)}`;
      return { expr, poly, steps };
    }

    function genTwoVarBinomialProduct() {
      const [v1, v2] = safeVarPair();
      const a = randInt(-6, 6);
      const b = randInt(-6, 6);
      const c = randInt(-6, 6);
      const d = randInt(-6, 6);

      // (v1 + a)(v2 + b) or (2v1 + a)(v2 - b)
      const pat = randInt(1, 2);
      if (pat === 1) {
        const expr = `(${v1} ${a < 0 ? "- " + Math.abs(a) : "+ " + a}) (${v2} ${b < 0 ? "- " + Math.abs(b) : "+ " + b})`;
        const p1 = addPolys(makeMono(1, { [v1]: 1 }), makeConst(a));
        const p2 = addPolys(makeMono(1, { [v2]: 1 }), makeConst(b));
        const poly = mulPolys(p1, p2);
        const steps =
          `${expr}\n` +
          `= ${v1}${v2} ${b < 0 ? "- " + Math.abs(b) + v1 : "+ " + b + v1} ${a < 0 ? "- " + Math.abs(a) + v2 : "+ " + a + v2} ${a*b < 0 ? "- " + Math.abs(a*b) : "+ " + (a*b)}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps };
      } else {
        const A = 2;
        const expr = `(${A}${v1} ${c < 0 ? "- " + Math.abs(c) : "+ " + c}) (${v2} ${d < 0 ? "- " + Math.abs(d) : "+ " + d})`;
        const p1 = addPolys(makeMono(A, { [v1]: 1 }), makeConst(c));
        const p2 = addPolys(makeMono(1, { [v2]: 1 }), makeConst(d));
        const poly = mulPolys(p1, p2);
        const steps =
          `${expr}\n` +
          `= ${A}${v1}${v2} ${d < 0 ? "- " + Math.abs(d) + "Â·" + A + v1 : "+ " + (d*A) + v1} ${c < 0 ? "- " + Math.abs(c) + v2 : "+ " + c + v2} ${c*d < 0 ? "- " + Math.abs(c*d) : "+ " + (c*d)}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps };
      }
    }

    function genFactorThenCombineStyle() {
      // a(x + by) - c(by - x) style, but still "simplify" by distributing
      const [v1, v2] = safeVarPair();
      const a = randNonZero(1, 4);
      const b = randNonZero(1, 4);
      const c = randNonZero(1, 4);

      const expr = `${a}(${v1} + ${b}${v2}) - ${c}(${b}${v2} - ${v1})`;
      const p1 = addPolys(makeMono(a, { [v1]: 1 }), makeMono(a*b, { [v2]: 1 }));
      const inner2 = subPolys(makeMono(b, { [v2]: 1 }), makeMono(1, { [v1]: 1 }));
      const p2 = mulPolys(makeConst(c), inner2);
      const poly = subPolys(p1, p2);

      const steps =
        `${expr}\n` +
        `= ${a}${v1} + ${a*b}${v2} - (${c*b}${v2} - ${c}${v1})\n` +
        `= ${a}${v1} + ${a*b}${v2} - ${c*b}${v2} + ${c}${v1}\n` +
        `= ${polyToString(poly)}`;

      return { expr, poly, steps };
    }

    /***********************
     * Difficulty pools
     ***********************/

    const easyGenerators = [
      // 1) combine like terms (one variable) with constants
      function () {
        const v = pick(["x", "y", "a", "b", "c"]);
        const t = randInt(2, 4);
        const base = genCombineLikeOneVar(v, t, -7, 7, -9, 9);
        return { ...base, difficulty: "easy" };
      },
      // 2) two variables, like terms
      function () {
        const [v1, v2] = safeVarPair();
        const base = genTwoVarLikeTerms(v1, v2);
        return { ...base, difficulty: "easy" };
      },
      // 3) distribute k(x - m) classic
      function () {
        const v = pick(["x", "y", "a", "b", "c"]);
        const k = randNonZero(2, 7);
        const m = randInt(1, 9);
        const expr = `${k}(${v} - ${m})`;
        const poly = addPolys(makeMono(k, { [v]: 1 }), makeConst(-k*m));
        const steps =
          `${expr}\n` +
          `= ${k}${v} - ${k*m}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "easy" };
      },
      // 4) distribute k(ax + b)
      function () {
        const v = pick(["x", "y", "a", "b", "c"]);
        const base = genDistributeLinear(v);
        return { ...base, difficulty: "easy" };
      },
      // 5) monomial products
      function () {
        const base = genMultiplyMonomials();
        return { ...base, difficulty: "easy" };
      },
      // 6) (x+a)(x+b) easy
      function () {
        const v = pick(["x", "y", "a", "b", "c"]);
        const base = genBinomialTimesBinomialSameVar(v);
        return { ...base, difficulty: "easy" };
      },
      // 7) (x+a)^2 easy
      function () {
        const v = pick(["x", "y", "a", "b", "c"]);
        const base = genSquareBinomial(v);
        return { ...base, difficulty: "easy" };
      },
      // 8) subtract a bracket with like terms: Dy - (Ey + Fy)
      function () {
        const v = pick(["x","y","a","b","c"]);
        const D = randNonZero(3, 12);
        const E = randNonZero(1, 9);
        const F = randNonZero(1, 9);
        const expr = `${D}${v} - (${E}${v} + ${F}${v})`;
        const poly = subPolys(makeMono(D, { [v]: 1 }), addPolys(makeMono(E, { [v]: 1 }), makeMono(F, { [v]: 1 })));
        const steps =
          `${expr}\n` +
          `= ${D}${v} - ${E}${v} - ${F}${v}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "easy" };
      }
    ];

    const mediumGenerators = [
      // 1) x(x - k)
      function () {
        const v = pick(["x","y","a","b","c"]);
        const k = randInt(1, 9);
        const expr = `${v}(${v} - ${k})`;
        const poly = subPolys(makeMono(1, { [v]: 2 }), makeMono(k, { [v]: 1 }));
        const steps =
          `${expr}\n` +
          `= ${v}Â·${v} - ${k}${v}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "medium" };
      },
      // 2) ay(2 - by) style generalized
      function () {
        const [v1, v2] = safeVarPair();
        const a = randNonZero(2, 6);
        const b = randNonZero(1, 6);
        const expr = `${a}${v1}(2 - ${b}${v1})`;
        const poly = addPolys(makeMono(2*a, { [v1]: 1 }), makeMono(-a*b, { [v1]: 2 }));
        const steps =
          `${expr}\n` +
          `= ${2*a}${v1} - ${a*b}${v1}Â²\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "medium" };
      },
      // 3) (ax+b)(cx+d) with integers
      function () {
        const v = pick(["x","y","a","b","c"]);
        const A = randNonZero(1, 5);
        const C = randNonZero(1, 5);
        const b = randInt(-9, 9);
        const d = randInt(-9, 9);
        const expr = `(${A}${v} ${b < 0 ? "- " + Math.abs(b) : "+ " + b}) (${C}${v} ${d < 0 ? "- " + Math.abs(d) : "+ " + d})`;
        const p1 = addPolys(makeMono(A, { [v]: 1 }), makeConst(b));
        const p2 = addPolys(makeMono(C, { [v]: 1 }), makeConst(d));
        const poly = mulPolys(p1, p2);
        const steps =
          `${expr}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "medium" };
      },
      // 4) (2x+a)(y-b)
      function () {
        const [vx, vy] = safeVarPair();
        const a = randInt(-6, 6);
        const b = randInt(1, 6);
        const expr = `(2${vx} ${a < 0 ? "- " + Math.abs(a) : "+ " + a}) (${vy} - ${b})`;
        const p1 = addPolys(makeMono(2, { [vx]: 1 }), makeConst(a));
        const p2 = addPolys(makeMono(1, { [vy]: 1 }), makeConst(-b));
        const poly = mulPolys(p1, p2);
        const steps =
          `${expr}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "medium" };
      },
      // 5) a(x + 2y) - by style generalized
      function () {
        const [v1, v2] = safeVarPair();
        const a = randNonZero(1, 6);
        const b = randNonZero(1, 6);
        const expr = `${a}(${v1} + 2${v2}) - ${b}${v2}`;
        const polyPart = addPolys(makeMono(a, { [v1]: 1 }), makeMono(2*a, { [v2]: 1 }));
        const poly = subPolys(polyPart, makeMono(b, { [v2]: 1 }));
        const steps =
          `${expr}\n` +
          `= ${a}${v1} + ${2*a}${v2} - ${b}${v2}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "medium" };
      },
      // 6) two-var binomial product
      function () {
        const base = genTwoVarBinomialProduct();
        return { ...base, difficulty: "medium" };
      },
      // 7) distribute then combine (two parentheses)
      function () {
        const base = genFactorThenCombineStyle();
        return { ...base, difficulty: "medium" };
      },
      // 8) 2y(y+a) + 6y(y-1) style randomized
      function () {
        const v = pick(["x","y","a","b","c"]);
        const a = randInt(1, 9);
        const m1 = pick([2,3,4,5,6]);
        const m2 = pick([3,4,5,6,7]);
        const expr = `${m1}${v}(${v} + ${a}) + ${m2}${v}(${v} - 1)`;
        const part1 = addPolys(makeMono(m1, { [v]: 2 }), makeMono(m1*a, { [v]: 1 }));
        const part2 = addPolys(makeMono(m2, { [v]: 2 }), makeMono(-m2, { [v]: 1 }));
        const poly = addPolys(part1, part2);
        const steps =
          `${expr}\n` +
          `= ${m1}${v}Â² + ${m1*a}${v} + ${m2}${v}Â² - ${m2}${v}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "medium" };
      }
    ];

    const hardGenerators = [
      // 1) 5a(a - b) - 2a(2a + b) style but randomized letters
      function () {
        const [v1, v2] = safeVarPair();
        const A = pick([3,4,5,6]);
        const B = pick([2,3,4]);
        const expr = `${A}${v1}(${v1} - ${v2}) - ${B}${v1}(2${v1} + ${v2})`;

        const p1 = addPolys(makeMono(A, { [v1]: 2 }), makeMono(-A, { [v1]: 1, [v2]: 1 }));
        const p2 = addPolys(makeMono(2*B, { [v1]: 2 }), makeMono(B, { [v1]: 1, [v2]: 1 }));
        const poly = subPolys(p1, p2);

        const steps =
          `${expr}\n` +
          `= ${A}${v1}Â² - ${A}${v1}${v2} - (${2*B}${v1}Â² + ${B}${v1}${v2})\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "hard" };
      },
      // 2) three brackets with x/y type: 6xy - 2x(y - 1) - 3y(x - 1) generalized
      function () {
        const [x, y] = safeVarPair();
        const A = pick([4,5,6,7,8]);
        const B = pick([2,3,4]);
        const C = pick([2,3,4]);
        const expr = `${A}${x}${y} - ${B}${x}(${y} - 1) - ${C}${y}(${x} - 1)`;

        const term1 = makeMono(A, { [x]: 1, [y]: 1 });
        const t2 = subPolys(makeMono(B, { [x]: 1, [y]: 1 }), makeMono(B, { [x]: 1 }));
        const t3 = subPolys(makeMono(C, { [x]: 1, [y]: 1 }), makeMono(C, { [y]: 1 }));
        const poly = subPolys(subPolys(term1, t2), t3);

        const steps =
          `${expr}\n` +
          `= ${A}${x}${y} - (${B}${x}${y} - ${B}${x}) - (${C}${x}${y} - ${C}${y})\n` +
          `= ${A}${x}${y} - ${B}${x}${y} + ${B}${x} - ${C}${x}${y} + ${C}${y}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "hard" };
      },
      // 3) difference of two binomial products: (ax+b)(cx+d) - (ex+f)(gx+h)
      function () {
        const v = pick(["x","y","a","b","c"]);
        const A = randNonZero(1, 5);
        const C = randNonZero(1, 5);
        const E = randNonZero(1, 5);
        const G = randNonZero(1, 5);

        const b = randInt(-9, 9);
        const d = randInt(-9, 9);
        const f = randInt(-9, 9);
        const h = randInt(-9, 9);

        const expr =
          `(${A}${v} ${b < 0 ? "- " + Math.abs(b) : "+ " + b})` +
          `(${C}${v} ${d < 0 ? "- " + Math.abs(d) : "+ " + d})` +
          ` - ` +
          `(${E}${v} ${f < 0 ? "- " + Math.abs(f) : "+ " + f})` +
          `(${G}${v} ${h < 0 ? "- " + Math.abs(h) : "+ " + h})`;

        const p1 = mulPolys(addPolys(makeMono(A, { [v]: 1 }), makeConst(b)), addPolys(makeMono(C, { [v]: 1 }), makeConst(d)));
        const p2 = mulPolys(addPolys(makeMono(E, { [v]: 1 }), makeConst(f)), addPolys(makeMono(G, { [v]: 1 }), makeConst(h)));
        const poly = subPolys(p1, p2);

        const steps =
          `${expr}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "hard" };
      },
      // 4) nested brackets: k(v + a(v - b)) - m(v - n)
      function () {
        const v = pick(["x","y","a","b","c"]);
        const k = randNonZero(2, 6);
        const a = randNonZero(2, 5);
        const b = randInt(1, 9);
        const m = randNonZero(2, 6);
        const n = randInt(1, 9);

        const expr = `${k}(${v} + ${a}(${v} - ${b})) - ${m}(${v} - ${n})`;
        const inside = addPolys(makeMono(1, { [v]: 1 }), addPolys(makeMono(a, { [v]: 1 }), makeConst(-a*b)));
        const left = mulPolys(makeConst(k), inside);
        const right = mulPolys(makeConst(m), addPolys(makeMono(1, { [v]: 1 }), makeConst(-n)));
        const poly = subPolys(left, right);

        const steps =
          `${expr}\n` +
          `= ${k}(${(1+a)}${v} - ${a*b}) - (${m}${v} - ${m*n})\n` +
          `= ${k*(1+a)}${v} - ${k*a*b} - ${m}${v} + ${m*n}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "hard" };
      },
      // 5) multi-variable: p v1(v1 + v2) - q v1(v2 - v1) + r v2(v1 - 1)
      function () {
        const [v1, v2] = safeVarPair();
        const p = pick([2,3,4]);
        const q = pick([2,3,4]);
        const r = pick([2,3,4]);

        const expr = `${p}${v1}(${v1} + ${v2}) - ${q}${v1}(${v2} - ${v1}) + ${r}${v2}(${v1} - 1)`;

        const t1 = addPolys(makeMono(p, { [v1]: 2 }), makeMono(p, { [v1]: 1, [v2]: 1 }));
        const t2 = mulPolys(makeConst(q), mulPolys(makeMono(1, { [v1]: 1 }), subPolys(makeMono(1, { [v2]: 1 }), makeMono(1, { [v1]: 1 }))));
        const t3 = mulPolys(makeConst(r), mulPolys(makeMono(1, { [v2]: 1 }), subPolys(makeMono(1, { [v1]: 1 }), makeConst(1))));
        const poly = addPolys(subPolys(t1, t2), t3);

        const steps =
          `${expr}\n` +
          `= ${polyToString(poly)}`;
        return { expr, poly, steps, difficulty: "hard" };
      },
      // 6) a deliberate "simplifies to 0" style sometimes, but not too often
      function () {
        const v = pick(["x","y","a","b","c"]);
        const k = randNonZero(2, 6);
        const m = randInt(1, 8);
        const expr = `${k}(${v} + ${m}) - ${k}${v} - ${k*m}`;
        const poly = makeConst(0);
        const steps =
          `${expr}\n` +
          `= ${k}${v} + ${k*m} - ${k}${v} - ${k*m}\n` +
          `= 0`;
        return { expr, poly, steps, difficulty: "hard" };
      }
    ];

    function generateProblemByDifficultyRaw(diff) {
      if (diff === "random") {
        const pool = ["easy", "medium", "hard"];
        diff = pool[randInt(0, pool.length - 1)];
      }
      let genArray;
      if (diff === "easy") genArray = easyGenerators;
      else if (diff === "medium") genArray = mediumGenerators;
      else genArray = hardGenerators;

      const gen = genArray[randInt(0, genArray.length - 1)];
      const prob = gen();
      prob.difficulty = diff; // enforce
      return prob;
    }

    function generateProblemByDifficulty(diff) {
      // Avoid repeats using recent memory (per difficulty)
      if (diff === "random") {
        // still track memory by the chosen actual difficulty
        const tries = 60;
        for (let i = 0; i < tries; i++) {
          const p = generateProblemByDifficultyRaw("random");
          const sig = signatureFor(p);
          if (!seenRecently(p.difficulty, sig)) {
            remember(p.difficulty, sig);
            return p;
          }
        }
        // fallback
        const p = generateProblemByDifficultyRaw("random");
        remember(p.difficulty, signatureFor(p));
        return p;
      } else {
        const tries = 60;
        for (let i = 0; i < tries; i++) {
          const p = generateProblemByDifficultyRaw(diff);
          const sig = signatureFor(p);
          if (!seenRecently(diff, sig)) {
            remember(diff, sig);
            return p;
          }
        }
        // fallback
        const p = generateProblemByDifficultyRaw(diff);
        remember(diff, signatureFor(p));
        return p;
      }
    }

    /*********************
     * Game state
     *********************/

    const difficultyButtons = document.querySelectorAll(".difficulty-button");
    const expressionDisplay = document.getElementById("expressionDisplay");
    const answerInput = document.getElementById("answerInput");
    const submitBtn = document.getElementById("submitBtn");
    const nextBtn = document.getElementById("nextBtn");
    const feedbackStatus = document.getElementById("feedbackStatus");
    const stepsContainer = document.getElementById("stepsContainer");
    const showStepsBtn = document.getElementById("showStepsBtn");

    const scoreDisplay = document.getElementById("scoreDisplay");
    const streakDisplay = document.getElementById("streakDisplay");
    const bestStreakDisplay = document.getElementById("bestStreakDisplay");
    const correctDisplay = document.getElementById("correctDisplay");
    const totalDisplay = document.getElementById("totalDisplay");
    const accuracyDisplay = document.getElementById("accuracyDisplay");
    const summaryList = document.getElementById("summaryList");

    const timerToggle = document.getElementById("timerToggle");
    const timerSelect = document.getElementById("timerSelect");
    const timerDisplay = document.getElementById("timerDisplay");
    const soundToggle = document.getElementById("soundToggle");
    const contrastToggle = document.getElementById("contrastToggle");

    const gameModeBtn = document.getElementById("gameModeBtn");
    const worksheetModeBtn = document.getElementById("worksheetModeBtn");
    const gameArea = document.getElementById("gameArea");
    const worksheetArea = document.getElementById("worksheetArea");

    const worksheetCountSelect = document.getElementById("worksheetCountSelect");
    const worksheetDiffSelect = document.getElementById("worksheetDiffSelect");
    const generateWorksheetBtn = document.getElementById("generateWorksheetBtn");
    const worksheetList = document.getElementById("worksheetList");
    const revealAllBtn = document.getElementById("revealAllBtn");
    const hideAllBtn = document.getElementById("hideAllBtn");

    let currentDifficulty = "easy";
    let currentProblem = null;
    let lastAnswerCorrect = false;

    let score = 0;
    let streak = 0;
    let bestStreak = 0;
    let correctCount = 0;
    let totalCount = 0;
    let incorrectHistory = [];

    let timerId = null;
    let timerRemaining = 0;

    function setDifficulty(diff) {
      currentDifficulty = diff;
      difficultyButtons.forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.diff === diff);
      });
      newProblem();
    }

    difficultyButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        setDifficulty(btn.dataset.diff);
      });
    });

    function updateScoreDisplays() {
      scoreDisplay.textContent = score;
      streakDisplay.textContent = streak;
      bestStreakDisplay.textContent = bestStreak;
      correctDisplay.textContent = correctCount;
      totalDisplay.textContent = totalCount;
      const acc = totalCount === 0 ? 0 : Math.round((100 * correctCount) / totalCount);
      accuracyDisplay.textContent = acc + "%";

      if (incorrectHistory.length === 0) {
        summaryList.textContent = "No incorrect answers yet.";
      } else {
        const ul = document.createElement("ul");
        for (const item of incorrectHistory) {
          const li = document.createElement("li");
          li.textContent =
            item.expr + "  â†’  Correct: " + item.correct + "  | Your answer: " + item.your;
          ul.appendChild(li);
        }
        summaryList.innerHTML = "";
        summaryList.appendChild(ul);
      }
    }

    function resetFeedback() {
      feedbackStatus.textContent = "";
      feedbackStatus.className = "feedback-status";
      stepsContainer.textContent = "";
      showStepsBtn.style.display = "none";
      lastAnswerCorrect = false;
    }

    function newProblem() {
      resetFeedback();
      currentProblem = generateProblemByDifficulty(currentDifficulty);
      expressionDisplay.textContent = prettyExpr(currentProblem.expr);
      answerInput.value = "";
      answerInput.focus();
      if (timerToggle.checked) {
        startTimer();
      } else {
        stopTimer();
      }
    }

    function startTimer() {
      stopTimer();
      timerRemaining = parseInt(timerSelect.value, 10);
      timerDisplay.textContent = timerRemaining;
      timerId = setInterval(() => {
        timerRemaining--;
        if (timerRemaining <= 0) {
          timerDisplay.textContent = "0";
          stopTimer();
        } else {
          timerDisplay.textContent = timerRemaining;
        }
      }, 1000);
    }

    function stopTimer() {
      if (timerId !== null) {
        clearInterval(timerId);
        timerId = null;
      }
      timerDisplay.textContent = timerToggle.checked ? timerRemaining : "--";
    }

    function playBeep(type) {
      if (!soundToggle.checked) return;
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = type === "correct" ? 880 : 220;
        gain.gain.setValueAtTime(0.15, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.2);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + 0.21);
      } catch (e) {
        // ignore audio errors
      }
    }

    contrastToggle.addEventListener("change", () => {
      if (contrastToggle.checked) {
        document.body.style.background = "#000000";
        document.body.style.color = "#ffffff";
      } else {
        document.body.style.background = getComputedStyle(document.documentElement)
          .getPropertyValue("--bg");
        document.body.style.color = getComputedStyle(document.documentElement)
          .getPropertyValue("--fg");
      }
    });

    timerToggle.addEventListener("change", () => {
      if (timerToggle.checked) startTimer();
      else stopTimer();
    });

    function checkAnswer() {
      if (!currentProblem) return;
      const userText = answerInput.value;
      const parsed = parseSimplifiedPolynomial(userText);
      if (!parsed.ok) {
        feedbackStatus.textContent = parsed.error;
        feedbackStatus.className = "feedback-status incorrect";
        showStepsBtn.style.display = "none";
        stepsContainer.textContent = "";
        playBeep("wrong");
        return;
      }

      const userPoly = parsed.poly;
      const expectedPoly = currentProblem.poly;

      const same =
        Object.keys(userPoly).length === Object.keys(expectedPoly).length &&
        Object.keys(userPoly).every(
          (k) => Object.prototype.hasOwnProperty.call(expectedPoly, k) && userPoly[k] === expectedPoly[k]
        );

      totalCount++;
      if (same) {
        correctCount++;
        streak++;
        if (streak > bestStreak) bestStreak = streak;
        score += 10;
        if (streak > 0 && streak % 5 === 0) score += 5;

        feedbackStatus.textContent = "Correct!";
        feedbackStatus.className = "feedback-status correct";
        showStepsBtn.style.display = "none";
        stepsContainer.textContent = "";
        lastAnswerCorrect = true;
        playBeep("correct");
      } else {
        streak = 0;
        feedbackStatus.textContent = "Incorrect. Try again or show steps.";
        feedbackStatus.className = "feedback-status incorrect";
        showStepsBtn.style.display = "inline-block";
        stepsContainer.textContent = "";
        lastAnswerCorrect = false;
        incorrectHistory.push({
          expr: expressionDisplay.textContent,
          correct: polyToString(expectedPoly),
          your: polyToString(userPoly)
        });
        playBeep("wrong");
      }
      updateScoreDisplays();
    }

    submitBtn.addEventListener("click", () => {
      if (lastAnswerCorrect) newProblem();
      else checkAnswer();
    });

    nextBtn.addEventListener("click", () => {
      newProblem();
    });

    answerInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        if (lastAnswerCorrect) newProblem();
        else checkAnswer();
      } else if (e.key === "Escape") {
        e.preventDefault();
        answerInput.value = "";
      }
    });

    showStepsBtn.addEventListener("click", () => {
      if (!currentProblem) return;
      const final = polyToString(currentProblem.poly);
      stepsContainer.textContent =
        prettyExpr(currentProblem.steps) +
        "\nFinal answer: " +
        final;
    });

    /********************
     * Worksheet logic
     ********************/

    let worksheetProblems = [];

    function updateWorksheetDisplay() {
      if (!worksheetProblems.length) {
        worksheetList.textContent = "No worksheet generated yet.";
        revealAllBtn.disabled = true;
        hideAllBtn.disabled = true;
        return;
      }
      const ol = document.createElement("ol");
      worksheetProblems.forEach((p, index) => {
        const li = document.createElement("li");
        const line = document.createElement("div");
        line.textContent = prettyExpr(p.expr);
        const ans = document.createElement("div");
        ans.className = "worksheet-answer";
        ans.textContent = "Answer: " + polyToString(p.poly);
        if (!p.revealed) ans.style.display = "none";
        li.appendChild(line);
        li.appendChild(ans);
        li.dataset.index = String(index);
        ol.appendChild(li);
      });
      worksheetList.innerHTML = "";
      worksheetList.appendChild(ol);
      revealAllBtn.disabled = false;
      hideAllBtn.disabled = false;
    }

    generateWorksheetBtn.addEventListener("click", () => {
      const count = parseInt(worksheetCountSelect.value, 10);
      const diff = worksheetDiffSelect.value;
      worksheetProblems = [];

      // Also avoid duplicates within the same worksheet generation
      const localSigs = new Set();
      let guard = 0;
      while (worksheetProblems.length < count && guard < 500) {
        guard++;
        const p = generateProblemByDifficulty(diff);
        const sig = signatureFor(p);
        if (localSigs.has(sig)) continue;
        localSigs.add(sig);
        p.revealed = false;
        worksheetProblems.push(p);
      }

      updateWorksheetDisplay();
    });

    revealAllBtn.addEventListener("click", () => {
      worksheetProblems.forEach((p) => (p.revealed = true));
      updateWorksheetDisplay();
    });

    hideAllBtn.addEventListener("click", () => {
      worksheetProblems.forEach((p) => (p.revealed = false));
      updateWorksheetDisplay();
    });

    /********************
     * Mode switching
     ********************/

    function setMode(mode) {
      if (mode === "game") {
        gameArea.style.display = "block";
        worksheetArea.style.display = "none";
        gameModeBtn.classList.add("active");
        worksheetModeBtn.classList.remove("active");
      } else {
        gameArea.style.display = "none";
        worksheetArea.style.display = "flex";
        gameModeBtn.classList.remove("active");
        worksheetModeBtn.classList.add("active");
      }
    }

    gameModeBtn.addEventListener("click", () => setMode("game"));
    worksheetModeBtn.addEventListener("click", () => setMode("worksheet"));

    /********************
     * Dev tests
     ********************/

    function runDevTests() {
      const out = [];
      function test(name, fn) {
        try {
          const result = fn();
          out.push((result ? "âœ… " : "âŒ ") + name);
        } catch (e) {
          out.push("âŒ " + name + " (error: " + e.message + ")");
        }
      }

      test("Easy coefficient bounds", () => {
        for (let i = 0; i < 60; i++) {
          const p = generateProblemByDifficultyRaw("easy").poly;
          for (const k in p) {
            if (!Object.prototype.hasOwnProperty.call(p, k)) continue;
            if (Math.abs(p[k]) > 60) return false;
          }
        }
        return true;
      });

      test("Medium coefficient bounds", () => {
        for (let i = 0; i < 60; i++) {
          const p = generateProblemByDifficultyRaw("medium").poly;
          for (const k in p) {
            if (!Object.prototype.hasOwnProperty.call(p, k)) continue;
            if (Math.abs(p[k]) > 120) return false;
          }
        }
        return true;
      });

      test("Hard coefficient bounds", () => {
        for (let i = 0; i < 60; i++) {
          const p = generateProblemByDifficultyRaw("hard").poly;
          for (const k in p) {
            if (!Object.prototype.hasOwnProperty.call(p, k)) continue;
            if (Math.abs(p[k]) > 250) return false;
          }
        }
        return true;
      });

      test("No variable z generated", () => {
        const regex = /z/;
        for (let i = 0; i < 100; i++) {
          const pr = generateProblemByDifficultyRaw("random");
          if (regex.test(pr.expr)) return false;
        }
        return true;
      });

      test("Parser: 3x + 2x - 5 equals 5x - 5", () => {
        const u = parseSimplifiedPolynomial("3x + 2x - 5");
        const v = parseSimplifiedPolynomial("5x - 5");
        if (!u.ok || !v.ok) return false;
        const up = u.poly;
        const vp = v.poly;
        return (
          Object.keys(up).length === Object.keys(vp).length &&
          Object.keys(up).every(
            (k) => Object.prototype.hasOwnProperty.call(vp, k) && up[k] === vp[k]
          )
        );
      });

      test("Correct answer logic test", () => {
        const p = generateProblemByDifficultyRaw("easy");
        const expected = polyToString(p.poly);
        const parsed = parseSimplifiedPolynomial(expected);
        if (!parsed.ok) return false;
        const userPoly = parsed.poly;
        return (
          Object.keys(userPoly).length === Object.keys(p.poly).length &&
          Object.keys(userPoly).every(
            (k) => Object.prototype.hasOwnProperty.call(p.poly, k) && userPoly[k] === p.poly[k]
          )
        );
      });

      test("Random difficulty picks all three types", () => {
        const seen = { easy: false, medium: false, hard: false };
        for (let i = 0; i < 120; i++) {
          const p = generateProblemByDifficultyRaw("random");
          seen[p.difficulty] = true;
        }
        return seen.easy && seen.medium && seen.hard;
      });

      return out.join("\n");
    }

    (function () {
      const params = new URLSearchParams(window.location.search);
      if (params.get("dev") === "1") {
        const panel = document.getElementById("dev-panel");
        const out = document.getElementById("dev-output");
        panel.style.display = "block";
        out.textContent = runDevTests();
      }
    })();

    // Initialize
    updateScoreDisplays();
    setDifficulty("easy");
    newProblem();
  </script>
</body>
</html>
